<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1463580718036">{:repl-history {:ide [], :local [&quot;(ns zeromq-example.core\n  (:require [clojure.core.async :as async]\n            [cheshire.core :as cheshire])\n  (:import (org.zeromq ZContext ZMQ))\n  (:import (java.util.zip Inflater)))\n\n(defn market-data []\n  (let [out (async/chan 1024)\n        context (ZMQ/context 1)\n        subscriber (.socket context ZMQ/SUB)]\n    (.connect subscriber \&quot;tcp://relay-us-central-1.eve-emdr.com:8050\&quot;)\n    (.subscribe subscriber (byte-array 0))\n    (async/thread\n     (try\n       (loop []\n         (let [data (.recv subscriber)]\n           (when true\n             (do\n               (async/&gt;!! out data)\n               (recur)))))\n       (catch Throwable ex\n         (println \&quot;Error occured: \&quot; ex)))\n     (async/close! out)\n     (println \&quot;Shutting down\&quot;)\n     (.term context))\n    out))\n\n(defn inflater [data]\n  (let [inflater (Inflater.)\n        decompressed (byte-array (* (alength data) 16))\n        _ (.setInput inflater data)\n        decompressed-size (.inflate inflater decompressed)\n        output (byte-array decompressed-size)]\n    (System/arraycopy decompressed 0 output 0 decompressed-size)\n    (String. output \&quot;UTF-8\&quot;)))\n\n\n;(let [c (market-data)]\n;  (loop []\n;    (println (:rows (first (:rowsets (cheshire/parse-string (inflater (async/&lt;!! c)) true)))))\n;    (recur))\n;  (async/close! c))\n\n&quot; &quot;(ns zeromq-example.core\n  (:require [clojure.core.async :as async]\n            [cheshire.core :as cheshire])\n  (:import (org.zeromq ZContext ZMQ))\n  (:import (java.util.zip Inflater)))\n\n(defn market-data []\n  (let [out (async/chan 1024)\n        context (ZMQ/context 1)\n        subscriber (.socket context ZMQ/SUB)]\n    (.connect subscriber \&quot;tcp://relay-us-central-1.eve-emdr.com:8050\&quot;)\n    (.subscribe subscriber (byte-array 0))\n    (async/thread\n     (try\n       (loop []\n         (let [data (.recv subscriber)]\n           (when true\n             (do\n               (async/&gt;!! out data)\n               (recur)))))\n       (catch Throwable ex\n         (println \&quot;Error occured: \&quot; ex)))\n     (async/close! out)\n     (println \&quot;Shutting down\&quot;)\n     (.term context))\n    out))\n\n(defn inflater [data]\n  (let [inflater (Inflater.)\n        decompressed (byte-array (* (alength data) 16))\n        _ (.setInput inflater data)\n        decompressed-size (.inflate inflater decompressed)\n        output (byte-array decompressed-size)]\n    (System/arraycopy decompressed 0 output 0 decompressed-size)\n    (String. output \&quot;UTF-8\&quot;)))\n\n\n(let [c (market-data)]\n  (for [row (:rowsets (cheshire/parse-string (inflater (async/&lt;!! c)) true))]\n    (for [r (:rows row)]\n      (println r))))\n\n(let [c (market-data)]\n  (:columns (cheshire/parse-string (inflater (async/&lt;!! c)) true)))\n\n\n\n&quot; &quot;(market-data)&quot; &quot;(* 1 2)&quot; &quot;(ns zeromq-example.core\n  (:require [clojure.core.async :as async]\n            [cheshire.core :as cheshire])\n  (:import (org.zeromq ZContext ZMQ))\n  (:import (java.util.zip Inflater)))&quot; &quot;(let [c (market-data)]\n  (for [row (:rowsets (cheshire/parse-string (inflater (async/&lt;!! c)) true))]\n    (for [r (:rows row)]\n      (println r))))&quot; &quot;(let [c (market-data)]\n  (:columns (cheshire/parse-string (inflater (async/&lt;!! c)) true)))&quot; &quot;(let [c (market-data)]\n  (async/go-loop []\n    (println (async/&lt;!! c))))&quot; &quot;(let [c (market-data)]\n  (async/go-loop []\n    (println (inflater (async/&lt;!! c)))))&quot; &quot;(let [c (market-data)]\n  (async/go-loop []\n    (println (inflater (async/&lt;!! c)))\n    (recur)))&quot; &quot;(ns zeromq-example.core\n  (:require [clojure.core.async :as async]\n            [cheshire.core :as cheshire]\n            [clojurewerkz.elastisch.rest :as esr]\n            [clojurewerkz.elastisch.rest.document :as esd])\n  (:import (org.zeromq ZContext ZMQ))\n  (:import (java.util.zip Inflater)))&quot; &quot;(defn process-market-data []\n  (let [c (market-data)]\n    (async/go-loop []\n      (async/&gt;!! order-chan (cheshire/parse-string (inflater (async/&lt;!! c)) true))\n      (recur))))&quot; &quot;(let [c (market-data)]\n  (cheshire/parse-string (inflater (async/&lt;!! c)) true))&quot; &quot;(let [c (market-data)\n      d (cheshire/parse-string (inflater (async/&lt;!! c)) true)]\n  (esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; d))&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (cheshire/parse-string (inflater (async/&lt;!! c)) true)]\n  (esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; d))&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (cheshire/parse-string (inflater (async/&lt;!! c)) true)]\n  ;(esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; d)\n  (:rows (:rowsets d)))&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (cheshire/parse-string (inflater (async/&lt;!! c)) true)]\n  ;(esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; d)\n  (:rowsets d))&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (cheshire/parse-string (inflater (async/&lt;!! c)) true)]\n  (esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; (:rowsets d))\n  ;(:rowsets d)\n  )&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (cheshire/parse-string (inflater (async/&lt;!! c)) true)]\n  (esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; (:rowsets d))\n  ;((:rowsets d))\n  )&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (cheshire/parse-string (inflater (async/&lt;!! c)) true)]\n  ;(esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; (:rowsets d))\n  (first (:rowsets d))\n  )&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (cheshire/parse-string (inflater (async/&lt;!! c)) true)]\n  ;(esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; (:rowsets d))\n  (:rowsets d)\n  )&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (cheshire/parse-string (inflater (async/&lt;!! c)) true)]\n  ;(esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; (:rowsets d))\n  (into {} (:rowsets d))\n  )&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (cheshire/parse-string (inflater (async/&lt;!! c)) true)]\n  (esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; (into {} (:rowsets d)))\n  (into {} (:rowsets d))\n  )&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (inflater (async/&lt;!! c))]\n  (esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; (into {} (:rowsets d)))\n  ;(into {} (:rowsets d))\n  )&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (inflater (async/&lt;!! c))]\n  ;(esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; (into {} (:rowsets d)))\n  d\n  )&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (cheshire/parse-string (inflater (async/&lt;!! c)) true)]\n  ;(esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; (into {} (:rowsets d)))\n  (into {} (:rowsets d))\n  )&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (cheshire/parse-string (inflater (async/&lt;!! c)) true)]\n  (esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; (into {} (:rowsets d)))\n  ;(into {} (:rowsets d))\n  )&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (cheshire/parse-string (inflater (async/&lt;!! c)) true)]\n  (esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; d)\n  ;(into {} (:rowsets d))\n  )&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (into {} (:rowsets (cheshire/parse-string (inflater (async/&lt;!! c)) true)))]\n  (esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; d)\n  ;(into {} (:rowsets d))\n  )&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (into {} (:rowsets (cheshire/parse-string (inflater (async/&lt;!! c)) true)))]\n  ;(esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; d)\n  d\n  )&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (into {} (:rowsets (cheshire/parse-string (inflater (async/&lt;!! c)) true)))]\n  ;(esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; d)\n  (:rows d)\n  )&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (into {} (:rowsets (cheshire/parse-string (inflater (async/&lt;!! c)) true)))]\n  ;(esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; d)\n  (into {} (:rows d))\n  )&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (into {} (:rowsets (cheshire/parse-string (inflater (async/&lt;!! c)) true)))]\n  ;(esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; d)\n  (into () (:rows d))\n  )&quot; &quot;(defn persist-data []\n  (let [connection (esr/connect)]\n    (async/go-loop []\n      (esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; (async/&lt;!! order-chan)))))&quot; &quot;(defn write-to-disk []\n  (with-open [w (clojure.java.io/writer \&quot;/Users/e20042/data.txt\&quot; :append true)]\n    (async/go-loop []\n      (.write w (async/&lt;!! order-chan)))))&quot; &quot;(defn start []\n  (process-market-data)\n  ;(persist-data)\n  (write-to-disk))&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (cheshire/parse-string (inflater (async/&lt;!! c)) true)]\n  ;(esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; d)\n  d)&quot; &quot;(let [connection (esr/connect)\n      c (market-data)\n      d (cheshire/parse-string (inflater (async/&lt;!! c)) true)]\n  ;(esd/create connection \&quot;emdr\&quot; \&quot;orders\&quot; d)\n  d&quot; &quot;(defn process-market-data []\n  (let [c (market-data)]\n    (async/go-loop []\n      (async/&gt;!! order-chan (inflater (async/&lt;!! c)))\n      (recur))))&quot; &quot;(defn process-market-data []\n  (async/go-loop [ch (market-data)]\n    (if-let [c (async/&lt;!! ch)]\n      (async/&gt;!! order-chan (inflater c))\n      (recur ch))))&quot; &quot;(defn start []\n  (process-market-data)\n  ;(persist-data)\n  (write-thousand-lines \&quot;/tmp/data.txt\&quot;))&quot; &quot;(start)&quot; &quot;(ns zeromq-example.core\n  (:require [clojure.core.async :as async]\n            [clojure.java.io :as io])\n  (:import (org.zeromq ZMQ))\n  (:import (java.util.zip Inflater)))\n\n(defn market-data []\n  (let [out (async/chan 1024)\n        context (ZMQ/context 1)\n        subscriber (.socket context ZMQ/SUB)]\n    (.connect subscriber \&quot;tcp://relay-us-central-1.eve-emdr.com:8050\&quot;)\n    (.subscribe subscriber (byte-array 0))\n    (async/thread\n     (try\n       (loop []\n         (let [data (.recv subscriber)]\n           (when true\n             (do\n               (async/&gt;!! out data)\n               (recur)))))\n       (catch Throwable ex\n         (println \&quot;Error occured: \&quot; ex)))\n     (async/close! out)\n     (println \&quot;Shutting down\&quot;)\n     (.term context))\n    out))\n\n(defn inflater [data]\n  (let [inflater (Inflater.)\n        decompressed (byte-array (* (alength data) 16))\n        _ (.setInput inflater data)\n        decompressed-size (.inflate inflater decompressed)\n        output (byte-array decompressed-size)]\n    (System/arraycopy decompressed 0 output 0 decompressed-size)\n    (String. output \&quot;UTF-8\&quot;)))\n\n(def order-chan (async/chan 1024))\n\n(defn process-market-data []\n  (async/go-loop [ch (market-data)]\n    (if-let [c (async/&lt;!! ch)]\n      (async/&gt;!! order-chan (inflater c))\n      (recur ch))))\n\n\n(defn write-thousand-lines [filename]\n  (with-open [wrt (io/writer filename)]\n    (dotimes [_ 1000]\n      (.write wrt (async/&lt;!! order-chan)))))\n\n(defn start []\n  (process-market-data)\n  ;(persist-data)\n  (write-thousand-lines \&quot;/tmp/data.txt\&quot;))\n\n\n(start)\n&quot; &quot;(defn process-market-data [m-chan o-chan]\n  (async/go-loop []\n    (if-let [c (async/&lt;!! m-chan)]\n      (println \&quot;Processing \&quot; c)\n      (async/&gt;!! o-chan (inflater c))\n      (recur))))&quot; &quot;(defn process-market-data [m-chan o-chan]\n  (async/go-loop []\n    (when-let [c (async/&lt;!! m-chan)]\n      (println \&quot;Processing \&quot; c)\n      (async/&gt;!! o-chan (inflater c))\n      (recur))))&quot; &quot;(defn write-thousand-lines [filename]\n  (with-open [wrt (io/writer filename)]\n    (dotimes [_ 1000]\n      (.write wrt (async/&lt;!! order-chan)))))&quot; &quot;(defn write-thousand-lines [o-chan filename]\n  (with-open [wrt (io/writer filename)]\n    (dotimes [_ 1000]\n      (.write wrt (async/&lt;!! o-chan)))))&quot; &quot;(defn start [m-chan o-chan]\n  (process-market-data m-chan o-chan)\n  (write-thousand-lines o-chan \&quot;/tmp/data.txt\&quot;))&quot; &quot;(defn write-to-file [o-chan filename]\n  (with-open [wrt (io/writer filename)]\n    (if-let [d (async/&lt;!! o-chan)]\n      (.write wrt d)\n      (println \&quot;Order Channel has been closed\&quot;))))&quot; &quot;(ns zeromq-example.core\n  (:require [clojure.core.async :as async]\n            [clojure.java.io :as io])\n  (:import (org.zeromq ZMQ))\n  (:import (java.util.zip Inflater)))\n\n(defn market-data []\n  (let [out (async/chan 1024)\n        context (ZMQ/context 1)\n        subscriber (.socket context ZMQ/SUB)]\n    (.connect subscriber \&quot;tcp://relay-us-central-1.eve-emdr.com:8050\&quot;)\n    (.subscribe subscriber (byte-array 0))\n    (async/thread\n     (try\n       (loop []\n         (let [data (.recv subscriber)]\n           (when true\n             (do\n               (async/&gt;!! out data)\n               (recur)))))\n       (catch Throwable ex\n         (println \&quot;Error occured: \&quot; ex)))\n     (async/close! out)\n     (println \&quot;Shutting down\&quot;)\n     (.term context))\n    out))\n\n(defn inflater [data]\n  (let [inflater (Inflater.)\n        decompressed (byte-array (* (alength data) 16))\n        _ (.setInput inflater data)\n        decompressed-size (.inflate inflater decompressed)\n        output (byte-array decompressed-size)]\n    (System/arraycopy decompressed 0 output 0 decompressed-size)\n    (String. output \&quot;UTF-8\&quot;)))\n\n(defn process-market-data [m-chan o-chan]\n  (async/go-loop []\n    (if-let [c (inflater (async/&lt;!! m-chan))]\n      (do (async/&gt;!! o-chan c)\n          (recur))\n      (println \&quot;Market data channel has been closed!!\&quot;))))\n\n\n(defn write-to-file [o-chan filename]\n  (with-open [wrt (io/writer filename)]\n    (async/go-loop []\n      (if-let [d (async/&lt;!! o-chan)]\n        (do (.write wrt d) (recur))\n        (println \&quot;Order Channel has been closed\&quot;)))))\n\n(defn start [m-chan o-chan]\n  (process-market-data m-chan o-chan)\n  (write-to-file o-chan \&quot;/tmp/data.txt\&quot;))\n\n(defn stop [m-chan o-chan]\n  (async/close! m-chan)\n  (async/close! o-chan))&quot; &quot;(ns zeromq-example.core\n  (:require [clojure.core.async :as async]\n            [clojure.java.io :as io])\n  (:import (org.zeromq ZMQ))\n  (:import (java.util.zip Inflater)))&quot; &quot;(defn market-data []\n  (let [out (async/chan 1024)\n        context (ZMQ/context 1)\n        subscriber (.socket context ZMQ/SUB)]\n    (.connect subscriber \&quot;tcp://relay-us-central-1.eve-emdr.com:8050\&quot;)\n    (.subscribe subscriber (byte-array 0))\n    (async/thread\n     (try\n       (loop []\n         (let [data (.recv subscriber)]\n           (when true\n             (do\n               (async/&gt;!! out data)\n               (recur)))))\n       (catch Throwable ex\n         (println \&quot;Error occured: \&quot; ex)))\n     (async/close! out)\n     (println \&quot;Shutting down\&quot;)\n     (.term context))\n    out))&quot; &quot;(defn inflater [data]\n  (let [inflater (Inflater.)\n        decompressed (byte-array (* (alength data) 16))\n        _ (.setInput inflater data)\n        decompressed-size (.inflate inflater decompressed)\n        output (byte-array decompressed-size)]\n    (System/arraycopy decompressed 0 output 0 decompressed-size)\n    (String. output \&quot;UTF-8\&quot;)))&quot; &quot;(defn process-market-data [m-chan o-chan]\n  (async/go-loop []\n    (if-let [c (inflater (async/&lt;!! m-chan))]\n      (do (async/&gt;!! o-chan c)\n          (recur))\n      (println \&quot;Market data channel has been closed!!\&quot;))))&quot; &quot;(defn write-to-file [o-chan filename]\n  (with-open [wrt (io/writer filename)]\n    (loop []\n      (if-let [d (async/&lt;!! o-chan)]\n        (do (.write wrt d)\n            (recur))\n        (println \&quot;Order Channel has been closed\&quot;)))))&quot; &quot;(defn start [m-chan o-chan]\n  (process-market-data m-chan o-chan)\n  (write-to-file o-chan \&quot;/tmp/data.txt\&quot;))&quot; &quot;(defn stop [m-chan o-chan]\n  (async/close! m-chan)\n  (async/close! o-chan))&quot; &quot;(def market-chan (market-data))&quot; &quot;(def order-chan (async/chan 1024))&quot; &quot;(ns zeromq-example.core\n  (:require [clojure.core.async :as async]\n            [clojure.java.io :as io])\n  (:import (org.zeromq ZMQ))\n  (:import (java.util.zip Inflater)))\n\n(defn market-data []\n  (let [out (async/chan 1024)\n        context (ZMQ/context 1)\n        subscriber (.socket context ZMQ/SUB)]\n    (.connect subscriber \&quot;tcp://relay-us-central-1.eve-emdr.com:8050\&quot;)\n    (.subscribe subscriber (byte-array 0))\n    (async/thread\n     (try\n       (loop []\n         (let [data (.recv subscriber)]\n           (when true\n             (do\n               (async/&gt;!! out data)\n               (recur)))))\n       (catch Throwable ex\n         (println \&quot;Error occured: \&quot; ex)))\n     (async/close! out)\n     (println \&quot;Shutting down\&quot;)\n     (.term context))\n    out))\n\n(defn inflater [data]\n  (let [inflater (Inflater.)\n        decompressed (byte-array (* (alength data) 16))\n        _ (.setInput inflater data)\n        decompressed-size (.inflate inflater decompressed)\n        output (byte-array decompressed-size)]\n    (System/arraycopy decompressed 0 output 0 decompressed-size)\n    (String. output \&quot;UTF-8\&quot;)))\n\n(defn process-market-data [m-chan o-chan]\n  (async/go-loop []\n    (if-let [c (inflater (async/&lt;!! m-chan))]\n      (do (async/&gt;!! o-chan c)\n          (recur))\n      (println \&quot;Market data channel has been closed!!\&quot;))))\n\n\n(defn write-to-file [o-chan filename]\n  (with-open [wrt (io/writer filename)]\n    (loop []\n      (if-let [d (async/&lt;!! o-chan)]\n        (do (.write wrt d)\n            (recur))\n        (println \&quot;Order Channel has been closed\&quot;)))))\n\n(defn start [m-chan o-chan]\n  (process-market-data m-chan o-chan)\n  (write-to-file o-chan \&quot;/tmp/data.txt\&quot;))\n\n(defn stop [m-chan o-chan]\n  (async/close! m-chan)\n  (async/close! o-chan))\n\n(def market-chan (market-data))\n(def order-chan (async/chan 1024))&quot; &quot;(start market-chan order-chan)&quot; &quot;(&lt;!! market-chan)&quot; &quot;(&lt;!! order-chan)&quot; &quot;(stop market-chan order-chan)&quot; &quot;(async/&lt;!! market-chan)&quot; &quot;(async/&lt;!! order-chan)&quot;], :remote []}}</component>
</project>